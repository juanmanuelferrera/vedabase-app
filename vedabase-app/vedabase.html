<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vedabase - Original Books</title>
    <link href="https://fonts.googleapis.com/css2?family=Sanskrit+Text:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .font-sanskrit {
            font-family: 'Sanskrit Text', serif;
        }
        .tab-button {
            padding: 1rem 1.5rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            background: white;
        }
        .tab-button:hover {
            background-color: #fff7ed;
            color: #ea580c;
        }
        .tab-button.active {
            border-bottom-color: #ea580c;
            color: #ea580c;
            font-weight: 600;
        }
        #content-frame {
            width: 100%;
            height: calc(100vh - 240px);
            border: none;
            background: white;
        }
        body.dark-mode #content-frame {
            background: #000000;
        }
        #search-results {
            max-height: 60vh;
            overflow-y: auto;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin: 1rem;
        }
        .search-result-item {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            transition: background 0.2s;
        }
        .search-result-item:hover {
            background: #fff7ed;
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-highlight {
            background: #fef3c7;
            font-weight: 600;
            padding: 0 2px;
        }
        .search-source {
            display: inline-block;
            padding: 2px 8px;
            background: #ea580c;
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 8px;
        }
        /* Loading spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ea580c;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 100px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }

        /* Search history dropdown */
        #search-history-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
        .search-history-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #f3f4f6;
            transition: background 0.2s;
        }
        .search-history-item:hover {
            background: #f9fafb;
        }
        .search-history-item:last-child {
            border-bottom: none;
        }
        .search-history-clear {
            padding: 0.5rem 1rem;
            text-align: center;
            color: #dc2626;
            font-weight: 600;
            cursor: pointer;
            border-top: 1px solid #e5e7eb;
        }
        .search-history-clear:hover {
            background: #fef2f2;
        }
        .search-input-wrapper {
            position: relative;
        }

        /* Dark mode styles - Elegant black theme */
        body.dark-mode {
            background: #000000;
            color: #ffffff;
        }
        body.dark-mode header {
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
        }
        body.dark-mode h1 {
            color: #fb923c !important;
        }
        body.dark-mode nav {
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
        }
        body.dark-mode .tab-button {
            background: #0a0a0a;
            color: #e5e7eb;
        }
        body.dark-mode .tab-button:hover {
            background: #1a1a1a;
            color: #fb923c;
        }
        body.dark-mode .tab-button.active {
            color: #fb923c;
            border-bottom-color: #fb923c;
        }
        body.dark-mode #content-frame {
            background: #000000;
        }
        body.dark-mode #search-results {
            background: #0a0a0a;
            border-color: #1a1a1a;
        }
        body.dark-mode .search-result-item {
            border-bottom-color: #1a1a1a;
        }
        body.dark-mode .search-result-item:hover {
            background: #1a1a1a;
        }
        body.dark-mode input, body.dark-mode button:not(#dark-mode-toggle):not(#prev-result-btn):not(#next-result-btn) {
            background: #1a1a1a;
            color: #ffffff;
            border-color: #2a2a2a;
        }
        body.dark-mode label span {
            color: #e5e7eb;
        }
        body.dark-mode #result-counter {
            background: rgba(10, 10, 10, 0.95);
            color: #ffffff;
            border-color: #2a2a2a;
        }
        body.dark-mode #search-history-dropdown {
            background: #1a1a1a;
            border-color: #2a2a2a;
        }
        body.dark-mode .search-history-item {
            border-bottom-color: #2a2a2a;
        }
        body.dark-mode .search-history-item:hover {
            background: #2a2a2a;
        }
        body.dark-mode .search-history-clear {
            color: #f87171;
            border-top-color: #2a2a2a;
        }
        body.dark-mode .search-history-clear:hover {
            background: #2a0a0a;
        }

        /* Print Styles */
        @media print {
            /* Hide navigation and UI elements */
            header, nav, #search-results, #bookmarks-panel,
            #loading, #prev-result-btn, #next-result-btn,
            #result-counter, #add-bookmark-btn, button {
                display: none !important;
            }

            /* Make content take full page */
            #content-frame {
                height: auto !important;
                border: none !important;
                box-shadow: none !important;
            }

            /* Ensure good contrast for printing */
            body {
                background: white !important;
                color: black !important;
            }

            /* Page breaks */
            h1, h2, h3 {
                page-break-after: avoid;
                page-break-inside: avoid;
            }

            /* Avoid breaking paragraphs */
            p {
                page-break-inside: avoid;
            }

            /* Search highlights should be visible when printing */
            .search-term-highlight {
                background: #ffeb3b !important;
                color: #000 !important;
                font-weight: bold !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-b from-amber-50 to-orange-50">
    <!-- Header -->
    <header class="bg-white shadow-md sticky top-0 z-50">
        <div class="container mx-auto px-6 py-4">
            <div class="flex items-center justify-center gap-3">
                <h1 class="text-3xl font-sanskrit text-orange-600">
                    Vedabase - Original Books
                </h1>
                <span class="text-xs font-mono text-gray-400 px-2 py-1 rounded-full border border-gray-200" style="font-size: 0.65rem; opacity: 0.6;">v1.3.0</span>
            </div>
            <!-- Search Bar -->
            <div class="mt-4">
                <div class="flex gap-2">
                    <div class="search-input-wrapper flex-1">
                        <input
                            type="text"
                            id="search-input"
                            placeholder="Search in current book or all books..."
                            class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500"
                        />
                        <div id="search-history-dropdown" class="hidden"></div>
                    </div>
                    <button id="search-btn" class="px-6 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition">
                        Search Current
                    </button>
                    <button id="search-all-btn" class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                        Search All
                    </button>
                    <button id="bookmarks-btn" class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition" title="View bookmarks">
                        🔖 Bookmarks
                    </button>
                    <button id="stats-btn" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition" title="View reading statistics">
                        📊 Stats
                    </button>
                </div>
                <div class="mt-2 flex items-center gap-4 flex-wrap">
                    <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                        <input type="checkbox" id="whole-word-search" class="w-4 h-4 text-orange-600 border-gray-300 rounded focus:ring-orange-500">
                        <span>Match whole words only</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                        <input type="checkbox" id="case-sensitive-search" class="w-4 h-4 text-orange-600 border-gray-300 rounded focus:ring-orange-500">
                        <span>Case sensitive</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm text-gray-700 cursor-pointer">
                        <input type="checkbox" id="regex-search" class="w-4 h-4 text-orange-600 border-gray-300 rounded focus:ring-orange-500">
                        <span>Use regex</span>
                    </label>
                    <button id="dark-mode-toggle" class="ml-auto px-4 py-2 bg-gray-800 text-white hover:bg-gray-700 rounded-lg transition" title="Toggle dark mode">
                        🌙 Dark Mode
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Navigation Tabs -->
    <nav class="bg-white border-b border-gray-200 sticky top-[72px] z-40">
        <div class="container mx-auto px-6">
            <div class="flex flex-wrap justify-center gap-2">
                <button class="tab-button active" data-src="vedabase-source/bg.html">
                    Bhagavad-gītā
                </button>
                <button class="tab-button" data-src="vedabase-source/sb.html">
                    Śrīmad Bhāgavatam
                </button>
                <button class="tab-button" data-src="vedabase-source/cc.html">
                    Caitanya Caritāmṛta
                </button>
                <button class="tab-button" data-src="vedabase-source/kb.html">
                    Kṛṣṇa Book
                </button>
                <button class="tab-button" data-src="vedabase-source/other.html">
                    Other Books
                </button>
                <button class="tab-button" data-src="vedabase-source/lec1.html">
                    Lectures 1
                </button>
                <button class="tab-button" data-src="vedabase-source/lec2.html">
                    Lectures 2
                </button>
            </div>
        </div>
    </nav>

    <!-- Loading indicator -->
    <div id="loading" class="hidden">
        <div class="spinner"></div>
    </div>

    <!-- Search Results -->
    <div id="search-results" class="hidden"></div>

    <!-- Bookmarks Panel -->
    <div id="bookmarks-panel" class="hidden"></div>

    <!-- Statistics Panel -->
    <div id="stats-panel" class="hidden"></div>

    <!-- Floating bookmark button (appears when reading) -->
    <button id="add-bookmark-btn" style="display: none; position: fixed; bottom: 120px; right: 32px; padding: 12px 16px; background: #7c3aed; color: white; border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); border: none; cursor: pointer; font-size: 16px; font-weight: 600; z-index: 100;" onmouseover="this.style.background='#6d28d9'" onmouseout="this.style.background='#7c3aed'" title="Add bookmark at current location">
        🔖 Add
    </button>

    <!-- Custom Note Dialog -->
    <div id="note-dialog" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">
            <h3 style="margin: 0 0 15px 0; color: #374151; font-size: 20px;">Add Note to Bookmark</h3>
            <p style="margin: 0 0 15px 0; color: #6b7280; font-size: 14px;">Add an optional note to help you remember why you bookmarked this location.</p>
            <textarea id="note-input" placeholder="Enter your note here (optional)..." style="width: 100%; min-height: 100px; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; font-family: inherit; resize: vertical; margin-bottom: 20px;"></textarea>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="note-cancel-btn" style="padding: 10px 20px; background: #f3f4f6; color: #374151; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">Cancel</button>
                <button id="note-save-btn" style="padding: 10px 20px; background: #7c3aed; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">Save Bookmark</button>
            </div>
        </div>
    </div>

    <!-- Navigation Buttons (fixed position) -->
    <button id="prev-result-btn" class="hidden" style="position: fixed; bottom: 32px; right: 200px; padding: 12px 24px; background: #2563eb; color: white; border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); border: none; cursor: pointer; font-size: 16px; font-weight: 600; z-index: 100;" onmouseover="this.style.background='#1d4ed8'" onmouseout="this.style.background='#2563eb'">
        ← Previous
    </button>
    <div id="result-counter" class="hidden" style="position: fixed; bottom: 40px; right: 380px; padding: 8px 16px; background: rgba(255, 255, 255, 0.95); color: #374151; border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); font-size: 14px; font-weight: 600; z-index: 100; border: 2px solid #e5e7eb;">
        Result <span id="current-result-num">1</span> of <span id="total-results">1</span>
    </div>
    <button id="next-result-btn" class="hidden" style="position: fixed; bottom: 32px; right: 32px; padding: 12px 24px; background: #ea580c; color: white; border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); border: none; cursor: pointer; font-size: 16px; font-weight: 600; z-index: 100;" onmouseover="this.style.background='#c2410c'" onmouseout="this.style.background='#ea580c'">
        Next →
    </button>

    <!-- Content Frame - loads ONE page at a time to save memory -->
    <main class="container mx-auto">
        <iframe id="content-frame" src="vedabase-source/bg.html" sandbox="allow-same-origin allow-scripts allow-forms"></iframe>
    </main>

    <script>
        // Load dark mode preference (default: OFF)
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') {
            document.body.classList.add('dark-mode');
        }


        // Dark mode toggle
        window.addEventListener('load', () => {
            const btnDarkMode = document.getElementById('dark-mode-toggle');

            // Update button text based on current mode
            function updateButton() {
                const isDark = document.body.classList.contains('dark-mode');
                if (btnDarkMode) {
                    btnDarkMode.textContent = isDark ? '☀️ Light Mode' : '🌙 Dark Mode';
                }
            }

            updateButton();

            // Function to apply dark mode to iframe by adding/removing class
            function applyDarkModeToIframe(isDark) {
                const iframe = document.getElementById('content-frame');
                if (iframe && iframe.contentWindow && iframe.contentWindow.document) {
                    try {
                        const iframeBody = iframe.contentWindow.document.body;
                        if (iframeBody) {
                            if (isDark) {
                                iframeBody.classList.add('dark-mode');
                            } else {
                                iframeBody.classList.remove('dark-mode');
                            }
                        }
                    } catch (e) {
                        // Iframe not yet loaded or cross-origin, ignore
                    }
                }
            }

            if (btnDarkMode) {
                btnDarkMode.addEventListener('click', () => {
                    document.body.classList.toggle('dark-mode');
                    const isDark = document.body.classList.contains('dark-mode');
                    localStorage.setItem('darkMode', isDark);
                    updateButton();
                    applyDarkModeToIframe(isDark);
                });
            }

            // Apply dark mode when iframe loads
            const contentFrame = document.getElementById('content-frame');
            if (contentFrame) {
                contentFrame.addEventListener('load', () => {
                    const isDark = document.body.classList.contains('dark-mode');
                    applyDarkModeToIframe(isDark);
                });

                // Try to apply multiple times to handle race conditions
                // This ensures dark mode works on initial load and when content changes
                const applyOnLoad = () => {
                    const isDark = document.body.classList.contains('dark-mode');
                    applyDarkModeToIframe(isDark);
                };

                setTimeout(applyOnLoad, 50);
                setTimeout(applyOnLoad, 200);
                setTimeout(applyOnLoad, 500);
                setTimeout(applyOnLoad, 1000);
            }
        });

        // Memory-efficient: Only ONE iframe, switches content on demand
        const contentFrame = document.getElementById('content-frame');
        const loading = document.getElementById('loading');
        const buttons = document.querySelectorAll('.tab-button');

        // Cache for loaded pages to speed up switching
        const loadedPages = new Set(['vedabase-source/bg.html']);
        let currentSrc = 'vedabase-source/bg.html';
        let isLoading = false;

        buttons.forEach(button => {
            button.addEventListener('click', function() {
                const src = this.getAttribute('data-src');

                // Don't reload if already on this page
                if (src === currentSrc || isLoading) return;

                isLoading = true;
                currentSrc = src;

                // Remove active class from all buttons
                buttons.forEach(btn => btn.classList.remove('active'));

                // Add active class to clicked button
                this.classList.add('active');

                // Show loading immediately
                loading.classList.remove('hidden');
                contentFrame.classList.add('hidden');

                // Set timeout to show loading indicator for large files
                const loadStartTime = Date.now();

                // Load new content (browser automatically unloads previous iframe content)
                contentFrame.onload = function() {
                    loadedPages.add(src);
                    const loadTime = Date.now() - loadStartTime;

                    // Add small delay for smooth transition if load was too fast
                    const minDelay = loadTime < 100 ? 100 - loadTime : 0;

                    setTimeout(() => {
                        loading.classList.add('hidden');
                        contentFrame.classList.remove('hidden');
                        isLoading = false;

                        // Show Add Bookmark button when content is loaded
                        if (addBookmarkBtn) {
                            addBookmarkBtn.style.display = 'inline-block';
                            addBookmarkBtn.style.visibility = 'visible';
                        }

                        // If there's an active search, apply it to the newly loaded page
                        if (window.currentSearchQuery) {
                            applySearchToLoadedFrame();
                        }
                    }, minDelay);
                };

                // Handle load errors
                contentFrame.onerror = function() {
                    loading.classList.add('hidden');
                    contentFrame.classList.remove('hidden');
                    isLoading = false;
                    alert('Error loading content. Please try again.');
                };

                // Change iframe source - this unloads previous content from memory
                contentFrame.src = src;
            });
        });

        // Show button on initial iframe load
        contentFrame.addEventListener('load', function initialLoad() {
            if (addBookmarkBtn) {
                addBookmarkBtn.style.display = 'inline-block';
                addBookmarkBtn.style.visibility = 'visible';
            }
            // Remove this listener after first load
            contentFrame.removeEventListener('load', initialLoad);
        });

        // Aggressive preloading - start preloading all pages after initial load
        window.addEventListener('load', () => {
            // Wait 1 second after initial load, then start preloading
            setTimeout(() => {
                const pagesToPreload = [
                    'vedabase-source/sb.html',
                    'vedabase-source/cc.html',
                    'vedabase-source/kb.html',
                    'vedabase-source/other.html',
                    'vedabase-source/lec1.html',
                    'vedabase-source/lec2.html'
                ];

                // Preload one at a time with hidden iframes
                let preloadIndex = 0;
                function preloadNext() {
                    if (preloadIndex >= pagesToPreload.length) return;

                    const src = pagesToPreload[preloadIndex];
                    if (loadedPages.has(src)) {
                        preloadIndex++;
                        preloadNext();
                        return;
                    }

                    // Create hidden iframe to preload
                    const preloadFrame = document.createElement('iframe');
                    preloadFrame.style.display = 'none';
                    preloadFrame.src = src;

                    preloadFrame.onload = function() {
                        loadedPages.add(src);
                        document.body.removeChild(preloadFrame);
                        preloadIndex++;
                        // Wait a bit before loading next to avoid overwhelming
                        setTimeout(preloadNext, 500);
                    };

                    preloadFrame.onerror = function() {
                        document.body.removeChild(preloadFrame);
                        preloadIndex++;
                        setTimeout(preloadNext, 500);
                    };

                    document.body.appendChild(preloadFrame);
                }

                preloadNext();
            }, 1000);
        });

        // Also preload on hover for immediate access
        buttons.forEach(button => {
            button.addEventListener('mouseenter', function() {
                const src = this.getAttribute('data-src');
                if (!loadedPages.has(src) && !isLoading && src !== currentSrc) {
                    const link = document.createElement('link');
                    link.rel = 'prefetch';
                    link.href = src;
                    document.head.appendChild(link);
                }
            });
        });

        // Reusable function to apply search highlighting to currently loaded frame
        function applySearchToLoadedFrame() {
            if (!window.currentSearchQuery) return;

            setTimeout(() => {
                try {
                    const iframeDoc = contentFrame.contentWindow.document;
                    const content = iframeDoc.getElementById('content');
                    if (!content) return;

                    // Remove existing highlights
                    const existingHighlights = iframeDoc.querySelectorAll('.search-term-highlight');
                    existingHighlights.forEach(el => {
                        const parent = el.parentNode;
                        parent.replaceChild(iframeDoc.createTextNode(el.textContent), el);
                        parent.normalize();
                    });

                    // Apply new highlights
                    const wholeWord = document.getElementById('whole-word-search').checked;
                    const caseSensitive = document.getElementById('case-sensitive-search').checked;
                    const regexFlags = caseSensitive ? 'g' : 'gi';

                    let regex;
                    if (window.currentIsRegex) {
                        // Use the query as a regex pattern directly
                        try {
                            regex = new RegExp(`(${window.currentSearchQuery})`, regexFlags);
                        } catch (e) {
                            console.error('Invalid regex for highlighting:', e);
                            return;
                        }
                    } else {
                        // Escape special characters for literal search
                        const escapedQuery = window.currentSearchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        regex = wholeWord
                            ? new RegExp(`\\b(${escapedQuery})\\b`, regexFlags)
                            : new RegExp(`(${escapedQuery})`, regexFlags);
                    }

                    const walker = iframeDoc.createTreeWalker(
                        content,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );

                    const nodesToReplace = [];
                    let node;

                    while (node = walker.nextNode()) {
                        if (node.textContent.match(regex)) {
                            nodesToReplace.push(node);
                        }
                    }

                    nodesToReplace.forEach(textNode => {
                        const span = iframeDoc.createElement('span');
                        span.innerHTML = textNode.textContent.replace(regex, '<mark class="search-term-highlight" style="background: #fef08a; padding: 2px 4px; border-radius: 2px; font-weight: 600;">$1</mark>');
                        textNode.parentNode.replaceChild(span, textNode);
                    });

                    console.log('Applied search highlighting to frame');
                } catch (e) {
                    console.error('Error applying search to frame:', e);
                }
            }, 500);
        }

        // Search functionality
        const searchInput = document.getElementById('search-input');
        const searchBtn = document.getElementById('search-btn');
        const searchAllBtn = document.getElementById('search-all-btn');
        const searchResults = document.getElementById('search-results');
        const nextResultBtn = document.getElementById('next-result-btn');
        const prevResultBtn = document.getElementById('prev-result-btn');
        const resultCounter = document.getElementById('result-counter');
        const currentResultNum = document.getElementById('current-result-num');
        const totalResults = document.getElementById('total-results');
        const searchHistoryDropdown = document.getElementById('search-history-dropdown');
        const bookmarksBtn = document.getElementById('bookmarks-btn');
        const bookmarksPanel = document.getElementById('bookmarks-panel');
        const addBookmarkBtn = document.getElementById('add-bookmark-btn');
        const statsBtn = document.getElementById('stats-btn');
        const statsPanel = document.getElementById('stats-panel');

        // Store all search results and current index
        let allSearchResults = [];
        let unfilteredSearchResults = []; // Store original results before filtering
        let currentSearchOriginalQuery = ''; // Store the original query
        let currentResultIndex = -1;

        // Search History Management
        const MAX_HISTORY_ITEMS = 20;

        function getSearchHistory() {
            try {
                const history = localStorage.getItem('searchHistory');
                return history ? JSON.parse(history) : [];
            } catch (e) {
                console.error('Error loading search history:', e);
                return [];
            }
        }

        function saveSearchHistory(query) {
            if (!query || query.trim().length < 2) return;

            try {
                let history = getSearchHistory();

                // Remove duplicate if exists
                history = history.filter(item => item !== query);

                // Add to beginning
                history.unshift(query);

                // Keep only last MAX_HISTORY_ITEMS
                history = history.slice(0, MAX_HISTORY_ITEMS);

                localStorage.setItem('searchHistory', JSON.stringify(history));
            } catch (e) {
                console.error('Error saving search history:', e);
            }
        }

        function clearSearchHistory() {
            try {
                localStorage.removeItem('searchHistory');
                hideSearchHistory();
            } catch (e) {
                console.error('Error clearing search history:', e);
            }
        }

        function showSearchHistory() {
            const history = getSearchHistory();

            if (history.length === 0) {
                searchHistoryDropdown.classList.add('hidden');
                return;
            }

            let html = '';
            history.forEach(item => {
                html += `
                    <div class="search-history-item" data-query="${item.replace(/"/g, '&quot;')}">
                        <span>${item}</span>
                        <span style="color: #9ca3af; font-size: 0.875rem;">↵</span>
                    </div>
                `;
            });

            html += `<div class="search-history-clear" id="clear-history-btn">Clear History</div>`;

            searchHistoryDropdown.innerHTML = html;
            searchHistoryDropdown.classList.remove('hidden');
        }

        function hideSearchHistory() {
            searchHistoryDropdown.classList.add('hidden');
        }

        // Show history when input is focused
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.trim() === '') {
                showSearchHistory();
            }
        });

        // Hide history when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchInput.contains(e.target) && !searchHistoryDropdown.contains(e.target)) {
                hideSearchHistory();
            }
        });

        // Handle clicks on history items
        searchHistoryDropdown.addEventListener('click', (e) => {
            const historyItem = e.target.closest('.search-history-item');
            const clearBtn = e.target.closest('#clear-history-btn');

            if (historyItem) {
                const query = historyItem.dataset.query;
                searchInput.value = query;
                hideSearchHistory();
                performSearch(query, false);
            } else if (clearBtn) {
                clearSearchHistory();
            }
        });

        // Common search suggestions
        const searchSuggestions = [
            'Krishna', 'Arjuna', 'dharma', 'karma', 'yoga', 'soul', 'devotion', 'surrender',
            'meditation', 'knowledge', 'action', 'renunciation', 'bhakti', 'supreme',
            'eternal', 'birth', 'death', 'material', 'spiritual', 'mind', 'senses',
            'desire', 'love', 'service', 'wisdom', 'sacrifice', 'duty', 'self'
        ];

        // Filter history as user types with suggestions
        searchInput.addEventListener('input', () => {
            const value = searchInput.value.trim().toLowerCase();

            if (value === '') {
                showSearchHistory();
                return;
            }

            const history = getSearchHistory();
            const filteredHistory = history.filter(item => item.toLowerCase().includes(value));

            // Also filter suggestions
            const filteredSuggestions = searchSuggestions.filter(item =>
                item.toLowerCase().includes(value) &&
                !filteredHistory.some(h => h.toLowerCase() === item.toLowerCase())
            ).slice(0, 5); // Limit to 5 suggestions

            if (filteredHistory.length === 0 && filteredSuggestions.length === 0) {
                hideSearchHistory();
                return;
            }

            let html = '';

            // Show history first
            filteredHistory.forEach(item => {
                html += `
                    <div class="search-history-item" data-query="${item.replace(/"/g, '&quot;')}">
                        <span>🕐 ${item}</span>
                        <span style="color: #9ca3af; font-size: 0.875rem;">↵</span>
                    </div>
                `;
            });

            // Then show suggestions
            if (filteredSuggestions.length > 0 && filteredHistory.length > 0) {
                html += `<div style="padding: 0.5rem 1rem; background: #f3f4f6; font-size: 0.75rem; color: #6b7280; font-weight: 600;">SUGGESTIONS</div>`;
            }

            filteredSuggestions.forEach(item => {
                html += `
                    <div class="search-history-item" data-query="${item.replace(/"/g, '&quot;')}">
                        <span>💡 ${item}</span>
                        <span style="color: #9ca3af; font-size: 0.875rem;">↵</span>
                    </div>
                `;
            });

            searchHistoryDropdown.innerHTML = html;
            searchHistoryDropdown.classList.remove('hidden');
        });

        const bookNames = {
            'vedabase-source/bg.html': 'Bhagavad-gītā',
            'vedabase-source/sb.html': 'Śrīmad Bhāgavatam',
            'vedabase-source/cc.html': 'Caitanya Caritāmṛta',
            'vedabase-source/kb.html': 'Kṛṣṇa Book',
            'vedabase-source/other.html': 'Other Books',
            'vedabase-source/lec1.html': 'Lectures 1',
            'vedabase-source/lec2.html': 'Lectures 2'
        };

        // Optimized search with streaming and limits
        function performSearch(query, searchAll = false) {
            if (!query || query.trim().length < 2) {
                alert('Please enter at least 2 characters to search');
                return;
            }

            query = query.trim();

            // Save to search history
            saveSearchHistory(query);
            hideSearchHistory();

            const caseSensitive = document.getElementById('case-sensitive-search').checked;
            const useRegex = document.getElementById('regex-search').checked;
            const wholeWordOnly = document.getElementById('whole-word-search').checked;

            // Validate regex if useRegex is enabled
            let queryRegex;
            if (useRegex) {
                try {
                    const regexFlags = caseSensitive ? 'g' : 'gi';
                    queryRegex = new RegExp(query, regexFlags);
                } catch (e) {
                    alert('Invalid regular expression: ' + e.message);
                    return;
                }
            }

            currentSearchQuery = caseSensitive ? query : query.toLowerCase(); // Store for highlighting
            currentIsRegex = useRegex; // Store regex mode globally
            const queryForSearch = caseSensitive ? query : query.toLowerCase(); // Use this for searching
            const results = [];
            const filesToSearch = searchAll
                ? Object.keys(bookNames)
                : [currentSrc];

            const MAX_RESULTS_PER_FILE = 50; // Limit results per file
            const MAX_TOTAL_RESULTS = 200; // Stop after finding this many

            searchResults.innerHTML = `
                <div class="p-4 text-center">
                    <div class="spinner mx-auto"></div>
                    <p class="mt-2">Searching ${searchAll ? 'all books' : 'current book'}...</p>
                    <p class="text-sm text-gray-600 mt-1">Found <span id="result-count">0</span> results so far</p>
                </div>
            `;
            searchResults.classList.remove('hidden');
            contentFrame.classList.add('hidden');

            let processedFiles = 0;
            let totalResults = 0;

            const updateProgress = () => {
                const countEl = document.getElementById('result-count');
                if (countEl) countEl.textContent = totalResults;
            };

            filesToSearch.forEach((src, index) => {
                // Stagger requests to avoid overwhelming the browser
                setTimeout(() => {
                    if (totalResults >= MAX_TOTAL_RESULTS) {
                        processedFiles++;
                        if (processedFiles === filesToSearch.length) {
                            displayResults(results, query);
                        }
                        return;
                    }

                    fetch(src)
                        .then(response => response.text())
                        .then(html => {
                            // Use regex search instead of DOM parsing for speed
                            let searchRegex;
                            if (useRegex) {
                                // Already validated, just clone with g flag
                                const regexFlags = caseSensitive ? 'g' : 'gi';
                                searchRegex = new RegExp(query, regexFlags);
                            } else {
                                const escapedQuery = queryForSearch.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                const regexFlags = caseSensitive ? 'g' : 'gi';
                                searchRegex = wholeWordOnly
                                    ? new RegExp(`\\b${escapedQuery}\\b`, regexFlags)
                                    : new RegExp(escapedQuery, regexFlags);
                            }

                            // Extract just the content div to reduce parsing
                            const contentMatch = html.match(/<div id="content"[^>]*>([\s\S]*?)<\/div>\s*<div id="postamble"/);
                            if (!contentMatch) {
                                processedFiles++;
                                if (processedFiles === filesToSearch.length) {
                                    displayResults(results, query);
                                }
                                return;
                            }

                            const content = contentMatch[1];

                            // Find all paragraphs and headings with a simpler regex
                            const elementRegex = /<(p|h[1-6])[^>]*>([\s\S]*?)<\/\1>/gi;
                            let match;
                            let fileResults = 0;

                            while ((match = elementRegex.exec(content)) !== null && fileResults < MAX_RESULTS_PER_FILE && totalResults < MAX_TOTAL_RESULTS) {
                                const text = match[2].replace(/<[^>]+>/g, '').replace(/&[^;]+;/g, ' ');
                                const textToSearch = caseSensitive ? text : text.toLowerCase();

                                // Check if text matches query
                                const hasMatch = useRegex || wholeWordOnly
                                    ? searchRegex.test(textToSearch)
                                    : textToSearch.includes(queryForSearch);

                                // Reset regex for next iteration
                                searchRegex.lastIndex = 0;

                                if (hasMatch) {
                                    // Find match position
                                    let index;
                                    if (useRegex || wholeWordOnly) {
                                        searchRegex.lastIndex = 0;
                                        const matchResult = searchRegex.exec(textToSearch);
                                        index = matchResult ? matchResult.index : 0;
                                    } else {
                                        index = textToSearch.indexOf(queryForSearch);
                                    }

                                    const start = Math.max(0, index - 100);
                                    const end = Math.min(text.length, index + 100);
                                    let excerpt = text.substring(start, end).trim();

                                    if (start > 0) excerpt = '...' + excerpt;
                                    if (end < text.length) excerpt = excerpt + '...';

                                    // Highlight matches
                                    searchRegex.lastIndex = 0;
                                    excerpt = excerpt.replace(searchRegex, '<span class="search-highlight">$&</span>');

                                    // Get heading context - capture hierarchical parent headings only
                                    const precedingContent = content.substring(0, match.index);

                                    // Extract all headings with their levels using exec loop
                                    const headingRegex = /<(h[2-6])[^>]*id="([^"]*)"[^>]*>([^<]+)<\/\1>/g;
                                    const headings = [];
                                    let headingMatch;

                                    while ((headingMatch = headingRegex.exec(precedingContent)) !== null) {
                                        headings.push({
                                            level: parseInt(headingMatch[1].substring(1)), // h2 -> 2, h3 -> 3, etc.
                                            id: headingMatch[2],
                                            text: headingMatch[3].replace(/&[^;]+;/g, ' ').trim()
                                        });
                                    }

                                    let heading = 'Introduction';
                                    let headingId = '';

                                    if (headings.length > 0) {
                                        // Get the last (most specific) heading first
                                        const lastHeading = headings[headings.length - 1];
                                        headingId = lastHeading.id;
                                        const hierarchy = [lastHeading.text];
                                        let currentLevel = lastHeading.level;

                                        // Walk backwards to find parent headings (strictly lower level numbers)
                                        for (let i = headings.length - 2; i >= 0; i--) {
                                            const h = headings[i];
                                            if (h.level < currentLevel) {
                                                hierarchy.unshift(h.text);
                                                currentLevel = h.level;
                                                if (hierarchy.length >= 3) break; // Max 3 levels
                                            }
                                        }

                                        heading = hierarchy.join(' → ').substring(0, 200);
                                    }

                                    // Track which occurrence this is in the file (1st, 2nd, 3rd, etc.)
                                    const occurrenceIndex = fileResults + 1;

                                    results.push({
                                        source: bookNames[src],
                                        sourcePath: src,
                                        heading: heading,
                                        excerpt: excerpt,
                                        headingId: headingId,
                                        occurrenceIndex: occurrenceIndex  // Which match is this in the file
                                    });

                                    fileResults++;
                                    totalResults++;
                                    updateProgress();
                                }
                            }

                            processedFiles++;
                            if (processedFiles === filesToSearch.length || totalResults >= MAX_TOTAL_RESULTS) {
                                displayResults(results, query);
                            }
                        })
                        .catch(err => {
                            console.error(`Error searching ${src}:`, err);
                            processedFiles++;
                            if (processedFiles === filesToSearch.length) {
                                displayResults(results, query);
                            }
                        });
                }, index * 50); // Stagger by 50ms
            });
        }

        function displayResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = `
                    <div class="p-8 text-center">
                        <p class="text-gray-600 text-lg">No results found for "${query}"</p>
                        <button onclick="closeSearch()" class="mt-4 px-6 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700">
                            Close
                        </button>
                    </div>
                `;
                return;
            }

            let html = `
                <div class="p-4 border-b border-gray-200">
                    <div class="flex justify-between items-center gap-2 mb-3">
                        <h3 class="text-lg font-semibold">Found ${results.length} result${results.length > 1 ? 's' : ''} for "${query}"</h3>
                        <div class="flex gap-2">
                            <button onclick="exportSearchResults()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700" title="Export results to text file">
                                📥 Export
                            </button>
                            <button onclick="closeSearch()" class="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700">
                                Close
                            </button>
                        </div>
                    </div>
                    <div class="flex gap-2 items-center">
                        <input
                            type="text"
                            id="filter-results-input"
                            placeholder="Filter these results..."
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                        >
                        <button onclick="filterResults()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 text-sm">
                            🔍 Filter
                        </button>
                        <button onclick="clearFilter()" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 text-sm" id="clear-filter-btn" style="display: none;">
                            ✕ Clear
                        </button>
                    </div>
                </div>
            `;

            results.forEach((result, index) => {
                const occurrenceIndex = result.occurrenceIndex || 1;
                html += `
                    <div class="search-result-item"
                         data-source-path="${result.sourcePath}"
                         data-heading-id="${result.headingId}"
                         data-occurrence="${occurrenceIndex}"
                         data-result-index="${index}">
                        <div class="mb-2">
                            <span class="search-source">${result.source}</span>
                        </div>
                        <div class="text-base font-semibold text-gray-900 mb-1">${result.heading}</div>
                        <div class="text-gray-700 text-sm">${result.excerpt}</div>
                    </div>
                `;
            });

            searchResults.innerHTML = html;

            // Store results and show navigation buttons
            allSearchResults = results;
            unfilteredSearchResults = results; // Save original results
            currentSearchOriginalQuery = query; // Save original query
            currentResultIndex = -1;
            if (results.length > 0) {
                nextResultBtn.classList.remove('hidden');
                prevResultBtn.classList.remove('hidden');
            }

            // Add enter key listener to filter input
            setTimeout(() => {
                const filterInput = document.getElementById('filter-results-input');
                if (filterInput) {
                    filterInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            filterResults();
                        }
                    });
                }
            }, 100);
        }

        // Function to update result counter
        function updateResultCounter() {
            if (allSearchResults.length > 0 && currentResultIndex >= 0) {
                currentResultNum.textContent = currentResultIndex + 1;
                totalResults.textContent = allSearchResults.length;
                resultCounter.classList.remove('hidden');
            } else {
                resultCounter.classList.add('hidden');
            }
        }

        window.closeSearch = function() {
            searchResults.classList.add('hidden');
            contentFrame.classList.remove('hidden');
            nextResultBtn.classList.add('hidden');
            prevResultBtn.classList.add('hidden');
            resultCounter.classList.add('hidden');
            allSearchResults = [];
            unfilteredSearchResults = [];
            currentSearchOriginalQuery = '';
            currentResultIndex = -1;

            // Clear current search query to remove highlights
            currentSearchQuery = '';

            // Remove highlights from iframe
            try {
                const iframeDoc = contentFrame.contentWindow.document;
                const existingHighlights = iframeDoc.querySelectorAll('.search-term-highlight');
                existingHighlights.forEach(el => {
                    const parent = el.parentNode;
                    parent.replaceChild(iframeDoc.createTextNode(el.textContent), el);
                    parent.normalize();
                });
            } catch (e) {
                console.error('Error clearing highlights:', e);
            }
        };

        // Filter search results
        window.filterResults = function() {
            const filterInput = document.getElementById('filter-results-input');
            const filterTerm = filterInput ? filterInput.value.trim().toLowerCase() : '';

            if (!filterTerm || filterTerm.length < 2) {
                alert('Please enter at least 2 characters to filter');
                return;
            }

            if (unfilteredSearchResults.length === 0) {
                alert('No results to filter');
                return;
            }

            // Filter results based on excerpt, heading, or source
            const filtered = unfilteredSearchResults.filter(result => {
                const excerpt = result.excerpt.toLowerCase();
                const heading = result.heading.toLowerCase();
                const source = result.source.toLowerCase();
                return excerpt.includes(filterTerm) || heading.includes(filterTerm) || source.includes(filterTerm);
            });

            // Re-display with filtered results
            displayResults(filtered, `${currentSearchOriginalQuery}" filtered by "${filterTerm}`);

            // Show clear button
            const clearBtn = document.getElementById('clear-filter-btn');
            if (clearBtn) clearBtn.style.display = 'inline-block';
        };

        // Clear filter and restore original results
        window.clearFilter = function() {
            const filterInput = document.getElementById('filter-results-input');
            if (filterInput) filterInput.value = '';

            // Restore original results
            displayResults(unfilteredSearchResults, currentSearchOriginalQuery);

            // Hide clear button
            const clearBtn = document.getElementById('clear-filter-btn');
            if (clearBtn) clearBtn.style.display = 'none';
        };

        // Export search results to text file
        window.exportSearchResults = function() {
            if (allSearchResults.length === 0) {
                alert('No search results to export');
                return;
            }

            const query = searchInput.value.trim();
            const timestamp = new Date().toLocaleString();

            let textContent = `VEDABASE SEARCH RESULTS\n`;
            textContent += `=========================\n\n`;
            textContent += `Search Query: "${query}"\n`;
            textContent += `Total Results: ${allSearchResults.length}\n`;
            textContent += `Date: ${timestamp}\n\n`;
            textContent += `=========================\n\n`;

            allSearchResults.forEach((result, index) => {
                textContent += `[Result ${index + 1}]\n`;
                textContent += `Source: ${result.source}\n`;
                textContent += `Location: ${result.heading}\n`;
                textContent += `\n`;
                // Remove HTML tags from excerpt
                const plainText = result.excerpt.replace(/<[^>]+>/g, '').replace(/&[^;]+;/g, ' ');
                textContent += `${plainText}\n`;
                textContent += `\n${'='.repeat(50)}\n\n`;
            });

            // Create blob and download
            const blob = new Blob([textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vedabase-search-${query.replace(/[^a-z0-9]/gi, '_')}-${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`✓ Exported ${allSearchResults.length} search results`);
        };

        // Bookmarks System
        function getBookmarks() {
            try {
                const bookmarks = localStorage.getItem('vedabaseBookmarks');
                return bookmarks ? JSON.parse(bookmarks) : [];
            } catch (e) {
                console.error('Error loading bookmarks:', e);
                return [];
            }
        }

        function saveBookmark(bookmark) {
            alert('DEBUG saveBookmark: Function called with bookmark: ' + JSON.stringify(bookmark));
            try {
                alert('DEBUG saveBookmark: Getting existing bookmarks...');
                let bookmarks = getBookmarks();
                alert('DEBUG saveBookmark: Got ' + bookmarks.length + ' existing bookmarks');

                // Check if bookmark already exists at this location
                const exists = bookmarks.some(b =>
                    b.sourcePath === bookmark.sourcePath &&
                    b.headingId === bookmark.headingId
                );

                if (exists) {
                    alert('This location is already bookmarked!');
                    return false;
                }

                alert('DEBUG saveBookmark: Adding bookmark to array...');
                bookmarks.unshift(bookmark);

                alert('DEBUG saveBookmark: Saving to localStorage...');
                localStorage.setItem('vedabaseBookmarks', JSON.stringify(bookmarks));

                alert('DEBUG saveBookmark: Bookmark saved successfully!');
                console.log('✓ Bookmark saved');
                return true;
            } catch (e) {
                console.error('Error saving bookmark:', e);
                alert('DEBUG saveBookmark ERROR: ' + e.message + '\nStack: ' + e.stack);
                return false;
            }
        }

        function deleteBookmark(index) {
            try {
                let bookmarks = getBookmarks();
                bookmarks.splice(index, 1);
                localStorage.setItem('vedabaseBookmarks', JSON.stringify(bookmarks));
                showBookmarks(); // Refresh the display
                console.log('✓ Bookmark deleted');
            } catch (e) {
                console.error('Error deleting bookmark:', e);
            }
        }

        function showBookmarks() {
            const bookmarks = getBookmarks();

            bookmarksPanel.style.maxHeight = '60vh';
            bookmarksPanel.style.overflowY = 'auto';
            bookmarksPanel.style.background = document.body.classList.contains('dark-mode') ? '#000000' : 'white';
            bookmarksPanel.style.color = document.body.classList.contains('dark-mode') ? '#ffffff' : '#000000';
            bookmarksPanel.style.border = document.body.classList.contains('dark-mode') ? '1px solid #2a2a2a' : '1px solid #e5e7eb';
            bookmarksPanel.style.borderRadius = '8px';
            bookmarksPanel.style.margin = '1rem';

            if (bookmarks.length === 0) {
                bookmarksPanel.innerHTML = `
                    <div class="p-8 text-center">
                        <p class="text-gray-600 text-lg">No bookmarks yet</p>
                        <p class="text-gray-500 text-sm mt-2">Click the 🔖 Add button while reading to bookmark a location</p>
                        <button onclick="closeBookmarks()" class="mt-4 px-6 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700">
                            Close
                        </button>
                    </div>
                `;
                bookmarksPanel.classList.remove('hidden');
                contentFrame.classList.add('hidden');
                return;
            }

            let html = `
                <div class="p-4 border-b border-gray-200 flex justify-between items-center">
                    <h3 class="text-lg font-semibold">📚 My Bookmarks (${bookmarks.length})</h3>
                    <button onclick="closeBookmarks()" class="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700">
                        Close
                    </button>
                </div>
            `;

            bookmarks.forEach((bookmark, index) => {
                const date = new Date(bookmark.timestamp).toLocaleDateString();
                html += `
                    <div class="search-result-item" style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1; cursor: pointer;" onclick="openBookmark(${index})">
                            <div class="mb-2">
                                <span class="search-source">${bookmark.source}</span>
                            </div>
                            <div class="text-base font-semibold text-gray-900 mb-1">${bookmark.title}</div>
                            <div class="text-gray-500 text-xs">Added: ${date}</div>
                            ${bookmark.note ? `<div class="text-gray-700 text-sm mt-2 italic">"${bookmark.note}"</div>` : ''}
                        </div>
                        <button onclick="event.stopPropagation(); deleteBookmark(${index})"
                                class="ml-4 px-3 py-1 text-red-600 hover:bg-red-50 rounded"
                                title="Delete bookmark">
                            🗑️
                        </button>
                    </div>
                `;
            });

            bookmarksPanel.innerHTML = html;
            bookmarksPanel.classList.remove('hidden');
            contentFrame.classList.add('hidden');
            searchResults.classList.add('hidden');
        }

        window.closeBookmarks = function() {
            bookmarksPanel.classList.add('hidden');
            contentFrame.classList.remove('hidden');
        };

        window.openBookmark = function(index) {
            const bookmarks = getBookmarks();
            const bookmark = bookmarks[index];

            if (!bookmark) return;

            closeBookmarks();

            // Navigate to bookmarked location
            window.openResult(
                bookmark.sourcePath,
                bookmark.headingId,
                bookmark.title,
                1,
                -1
            );
        };

        // Show bookmarks when button clicked
        bookmarksBtn.addEventListener('click', showBookmarks);

        // Reading Progress Tracker
        function saveReadingProgress() {
            try {
                const iframeDoc = contentFrame.contentWindow.document;
                const scrollY = iframeDoc.documentElement.scrollTop || iframeDoc.body.scrollTop;

                const progress = {
                    sourcePath: currentSrc,
                    scrollPosition: scrollY,
                    timestamp: Date.now()
                };

                localStorage.setItem(`readingProgress_${currentSrc}`, JSON.stringify(progress));
            } catch (e) {
                console.error('Error saving reading progress:', e);
            }
        }

        function loadReadingProgress() {
            try {
                const progressData = localStorage.getItem(`readingProgress_${currentSrc}`);
                if (!progressData) return;

                const progress = JSON.parse(progressData);

                // Only restore if saved within last 7 days
                const daysSinceLastRead = (Date.now() - progress.timestamp) / (1000 * 60 * 60 * 24);
                if (daysSinceLastRead > 7) return;

                setTimeout(() => {
                    try {
                        const iframeDoc = contentFrame.contentWindow.document;
                        iframeDoc.documentElement.scrollTop = progress.scrollPosition;
                        iframeDoc.body.scrollTop = progress.scrollPosition;
                        console.log('✓ Restored reading position');
                    } catch (e) {
                        console.error('Error restoring scroll position:', e);
                    }
                }, 500);
            } catch (e) {
                console.error('Error loading reading progress:', e);
            }
        }

        // Save progress periodically while reading
        let progressSaveInterval;
        window.addEventListener('load', () => {
            // Load progress for initial page
            loadReadingProgress();

            // Save progress every 10 seconds while reading
            progressSaveInterval = setInterval(saveReadingProgress, 10000);
        });

        // Save progress when switching books
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                saveReadingProgress(); // Save before switching
            });
        });

        // Save progress when page unloads
        window.addEventListener('beforeunload', saveReadingProgress);

        // Load progress when iframe loads
        contentFrame.addEventListener('load', () => {
            setTimeout(loadReadingProgress, 1000);
        });

        // Reading Statistics
        function getStats() {
            try {
                const stats = localStorage.getItem('vedabaseStats');
                if (!stats) {
                    return {
                        firstOpened: Date.now(),
                        totalSearches: 0,
                        bookmarksCreated: 0,
                        booksVisited: {},
                        searchHistory: []
                    };
                }
                return JSON.parse(stats);
            } catch (e) {
                console.error('Error loading stats:', e);
                return {
                    firstOpened: Date.now(),
                    totalSearches: 0,
                    bookmarksCreated: 0,
                    booksVisited: {},
                    searchHistory: []
                };
            }
        }

        function saveStats(stats) {
            try {
                localStorage.setItem('vedabaseStats', JSON.stringify(stats));
            } catch (e) {
                console.error('Error saving stats:', e);
            }
        }

        function incrementSearchCount() {
            const stats = getStats();
            stats.totalSearches++;
            stats.searchHistory.push({
                query: searchInput.value.trim(),
                timestamp: Date.now()
            });
            saveStats(stats);
        }

        function trackBookVisit(bookPath) {
            const stats = getStats();
            if (!stats.booksVisited[bookPath]) {
                stats.booksVisited[bookPath] = {
                    visits: 0,
                    lastVisit: null
                };
            }
            stats.booksVisited[bookPath].visits++;
            stats.booksVisited[bookPath].lastVisit = Date.now();
            saveStats(stats);
        }

        function showStats() {
            const stats = getStats();
            const bookmarks = getBookmarks();
            const history = getSearchHistory();

            const daysSinceFirst = Math.floor((Date.now() - stats.firstOpened) / (1000 * 60 * 60 * 24));

            // Get most visited book
            let mostVisited = 'None';
            let maxVisits = 0;
            for (const [path, data] of Object.entries(stats.booksVisited)) {
                if (data.visits > maxVisits) {
                    maxVisits = data.visits;
                    mostVisited = bookNames[path] || path;
                }
            }

            statsPanel.style.maxHeight = '60vh';
            statsPanel.style.overflowY = 'auto';
            statsPanel.style.background = document.body.classList.contains('dark-mode') ? '#000000' : 'white';
            statsPanel.style.color = document.body.classList.contains('dark-mode') ? '#ffffff' : '#000000';
            statsPanel.style.border = document.body.classList.contains('dark-mode') ? '1px solid #2a2a2a' : '1px solid #e5e7eb';
            statsPanel.style.borderRadius = '8px';
            statsPanel.style.margin = '1rem';

            const isDark = document.body.classList.contains('dark-mode');
            const cardBg = isDark ? '#1a1a1a' : 'rgb(249 250 251)';
            const textColor = isDark ? '#ffffff' : '#000000';
            const subTextColor = isDark ? '#a0a0a0' : 'rgb(75 85 99)';

            const html = `
                <div class="p-4 border-b flex justify-between items-center" style="border-color: ${isDark ? '#2a2a2a' : 'rgb(229 231 235)'}">
                    <h3 class="text-lg font-semibold" style="color: ${textColor}">📊 Reading Statistics</h3>
                    <button onclick="closeStats()" class="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700">
                        Close
                    </button>
                </div>
                <div class="p-6 space-y-6">
                    <div class="grid grid-cols-2 gap-4">
                        <div class="p-4 rounded-lg" style="background: ${isDark ? '#1a1a3a' : 'rgb(239 246 255)'}">
                            <div class="text-3xl font-bold" style="color: ${isDark ? '#60a5fa' : 'rgb(37 99 235)'}">${daysSinceFirst}</div>
                            <div class="text-sm" style="color: ${subTextColor}">Days since first use</div>
                        </div>
                        <div class="p-4 rounded-lg" style="background: ${isDark ? '#2a1a3a' : 'rgb(250 245 255)'}">
                            <div class="text-3xl font-bold" style="color: ${isDark ? '#a78bfa' : 'rgb(147 51 234)'}">${stats.totalSearches}</div>
                            <div class="text-sm" style="color: ${subTextColor}">Total searches</div>
                        </div>
                        <div class="p-4 rounded-lg" style="background: ${isDark ? '#1a2a1a' : 'rgb(240 253 244)'}">
                            <div class="text-3xl font-bold" style="color: ${isDark ? '#4ade80' : 'rgb(22 163 74)'}">${bookmarks.length}</div>
                            <div class="text-sm" style="color: ${subTextColor}">Bookmarks saved</div>
                        </div>
                        <div class="p-4 rounded-lg" style="background: ${isDark ? '#2a1a0a' : 'rgb(255 247 237)'}">
                            <div class="text-3xl font-bold" style="color: ${isDark ? '#fb923c' : 'rgb(234 88 12)'}">${Object.keys(stats.booksVisited).length}</div>
                            <div class="text-sm" style="color: ${subTextColor}">Books explored</div>
                        </div>
                    </div>

                    <div class="border-t pt-4" style="border-color: ${isDark ? '#2a2a2a' : 'rgb(229 231 235)'}">
                        <h4 class="font-semibold mb-2" style="color: ${textColor}">📚 Most Visited Book</h4>
                        <div class="p-3 rounded" style="background: ${cardBg}">
                            <div class="font-medium" style="color: ${textColor}">${mostVisited}</div>
                            <div class="text-sm" style="color: ${subTextColor}">${maxVisits} visits</div>
                        </div>
                    </div>

                    <div class="border-t pt-4" style="border-color: ${isDark ? '#2a2a2a' : 'rgb(229 231 235)'}">
                        <h4 class="font-semibold mb-2" style="color: ${textColor}">🔍 Recent Searches</h4>
                        <div class="space-y-2">
                            ${history.slice(0, 5).map(query => `
                                <div class="p-2 rounded text-sm" style="background: ${cardBg}; color: ${textColor}">${query}</div>
                            `).join('') || `<div class="text-sm" style="color: ${subTextColor}">No searches yet</div>`}
                        </div>
                    </div>

                    <div class="border-t pt-4" style="border-color: ${isDark ? '#2a2a2a' : 'rgb(229 231 235)'}">
                        <h4 class="font-semibold mb-2" style="color: ${textColor}">📖 Book Visit Summary</h4>
                        <div class="space-y-2">
                            ${Object.entries(stats.booksVisited).map(([path, data]) => `
                                <div class="flex justify-between items-center p-2 rounded text-sm" style="background: ${cardBg}">
                                    <span style="color: ${textColor}">${bookNames[path] || path}</span>
                                    <span style="color: ${subTextColor}">${data.visits} visits</span>
                                </div>
                            `).join('') || `<div class="text-sm" style="color: ${subTextColor}">No visits tracked yet</div>`}
                        </div>
                    </div>
                </div>
            `;

            statsPanel.innerHTML = html;
            statsPanel.classList.remove('hidden');
            contentFrame.classList.add('hidden');
            searchResults.classList.add('hidden');
            bookmarksPanel.classList.add('hidden');
        }

        window.closeStats = function() {
            statsPanel.classList.add('hidden');
            contentFrame.classList.remove('hidden');
        };

        // Track stats when searching
        const originalPerformSearch = performSearch;
        function performSearchWithStats(query, searchAll) {
            incrementSearchCount();
            return originalPerformSearch(query, searchAll);
        }
        // Replace performSearch
        performSearch = performSearchWithStats;

        // Track book visits
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                const src = button.getAttribute('data-src');
                trackBookVisit(src);
            });
        });

        // Track initial book visit
        window.addEventListener('load', () => {
            trackBookVisit(currentSrc);
        });

        // Show stats when button clicked
        statsBtn.addEventListener('click', showStats);

        // Add bookmark at current location
        console.log('DEBUG: addBookmarkBtn =', addBookmarkBtn);
        if (addBookmarkBtn) {
            console.log('DEBUG: Attaching click listener to bookmark button');
            addBookmarkBtn.addEventListener('click', () => {
                console.log('DEBUG: Bookmark button clicked!');
                try {
                    console.log('DEBUG: contentFrame =', contentFrame);
                    console.log('DEBUG: Trying to access iframe document...');
                    const iframeDoc = contentFrame.contentWindow.document;
                    console.log('DEBUG: Got iframe document', iframeDoc);

                    // Get current scroll position and find nearest heading
                    const scrollY = iframeDoc.documentElement.scrollTop || iframeDoc.body.scrollTop;
                    console.log('DEBUG: Scroll position:', scrollY);

                    const headings = iframeDoc.querySelectorAll('h2[id], h3[id], h4[id], h5[id], h6[id]');
                    console.log('DEBUG: Found', headings.length, 'headings');

                    let nearestHeading = null;
                    let minDistance = Infinity;

                    headings.forEach(heading => {
                        const rect = heading.getBoundingClientRect();
                        const headingY = rect.top + scrollY;
                        const distance = Math.abs(headingY - scrollY);

                        if (distance < minDistance && headingY <= scrollY + 200) {
                            minDistance = distance;
                            nearestHeading = heading;
                        }
                    });

                    if (!nearestHeading) {
                        console.log('DEBUG: No nearest heading found!');
                        alert('Could not determine current location. Please scroll to a section heading.');
                        return;
                    }

                    console.log('DEBUG: Found nearest heading:', nearestHeading.textContent.trim());

                    // Show custom note dialog
                    const noteDialog = document.getElementById('note-dialog');
                    const noteInput = document.getElementById('note-input');
                    const noteSaveBtn = document.getElementById('note-save-btn');
                    const noteCancelBtn = document.getElementById('note-cancel-btn');

                    // Clear previous note
                    noteInput.value = '';

                    // Show dialog
                    noteDialog.style.display = 'flex';
                    noteInput.focus();

                    // Handle save button click
                    const handleSave = () => {
                        const note = noteInput.value.trim();
                        console.log('DEBUG: User entered note:', note);

                        const bookmark = {
                            source: bookNames[currentSrc],
                            sourcePath: currentSrc,
                            headingId: nearestHeading.id,
                            title: nearestHeading.textContent.trim(),
                            timestamp: Date.now(),
                            note: note
                        };

                        console.log('DEBUG: Bookmark object created:', bookmark);
                        const saveResult = saveBookmark(bookmark);
                        console.log('DEBUG: saveBookmark returned:', saveResult);

                        if (saveResult) {
                            // Show success message
                            const successMsg = document.createElement('div');
                            successMsg.textContent = '✓ Bookmark saved!';
                            successMsg.style.cssText = 'position: fixed; top: 80px; right: 32px; background: #10b981; color: white; padding: 16px 24px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 1001; font-weight: 600; animation: slideIn 0.3s ease;';
                            document.body.appendChild(successMsg);
                            setTimeout(() => {
                                successMsg.style.animation = 'slideOut 0.3s ease';
                                setTimeout(() => successMsg.remove(), 300);
                            }, 2000);
                        }

                        // Hide dialog and cleanup
                        noteDialog.style.display = 'none';
                        noteSaveBtn.removeEventListener('click', handleSave);
                        noteCancelBtn.removeEventListener('click', handleCancel);
                    };

                    // Handle cancel button click
                    const handleCancel = () => {
                        console.log('DEBUG: User cancelled bookmark');
                        noteDialog.style.display = 'none';
                        noteSaveBtn.removeEventListener('click', handleSave);
                        noteCancelBtn.removeEventListener('click', handleCancel);
                    };

                    noteSaveBtn.addEventListener('click', handleSave);
                    noteCancelBtn.addEventListener('click', handleCancel);

                    // Handle Enter key to save
                    const handleKeyPress = (e) => {
                        if (e.key === 'Enter' && e.ctrlKey) {
                            handleSave();
                            noteInput.removeEventListener('keypress', handleKeyPress);
                        } else if (e.key === 'Escape') {
                            handleCancel();
                            noteInput.removeEventListener('keypress', handleKeyPress);
                        }
                    };
                    noteInput.addEventListener('keypress', handleKeyPress);
                } catch (e) {
                    console.error('DEBUG: Error adding bookmark:', e);
                    console.error('DEBUG: Error message:', e.message);
                    console.error('DEBUG: Error stack:', e.stack);
                    alert('DEBUG ERROR: ' + e.message);
                }
            });
        } else {
            console.error('DEBUG ERROR: Bookmark button NOT found!');
        }

        // Store current search query and result info globally
        let currentSearchQuery = '';
        let currentIsRegex = false;
        let currentHeadingId = '';
        let currentOccurrenceIndex = 0;

        // Helper function to find nearest heading before an element
        function findNearestHeading(doc, element) {
            let current = element;
            while (current && current !== doc.body) {
                // Check previous siblings
                let prev = current.previousElementSibling;
                while (prev) {
                    if (prev.tagName && prev.tagName.match(/^H[2-6]$/i) && prev.id) {
                        return prev;
                    }
                    prev = prev.previousElementSibling;
                }
                current = current.parentElement;
            }
            return null;
        }

        // Helper function to expand TOC to show a specific heading
        function expandTOCToElement(doc, headingId) {
            console.log('expandTOCToElement called with headingId:', headingId);
            if (!headingId) {
                console.log('No headingId provided');
                return;
            }

            try {
                const toc = doc.getElementById('text-table-of-contents');
                if (!toc) {
                    console.log('TOC element not found');
                    return;
                }

                // Find the TOC link for this heading
                const tocLink = toc.querySelector(`a[href="#${headingId}"]`);
                console.log('Looking for TOC link with href:', `#${headingId}`, 'Found:', !!tocLink);
                if (!tocLink) {
                    console.log('TOC link not found for heading:', headingId);
                    return;
                }

                // Get the list item containing this link
                let tocItem = tocLink.parentElement;
                console.log('TOC item:', tocItem, 'Tag:', tocItem?.tagName);
                if (!tocItem || tocItem.tagName !== 'LI') {
                    console.log('TOC item is not an LI element');
                    return;
                }

                // First, collapse all TOC items to reset state
                const allItems = toc.querySelectorAll('li.expanded');
                console.log('Collapsing', allItems.length, 'expanded items');
                allItems.forEach(item => item.classList.remove('expanded'));

                // Remove any existing active highlighting
                const activeLinks = toc.querySelectorAll('a.toc-active');
                activeLinks.forEach(link => link.classList.remove('toc-active'));

                // Now expand all parent items up to the root
                let currentItem = tocItem;
                let expandedCount = 0;
                while (currentItem && currentItem.tagName === 'LI') {
                    console.log('Expanding item:', currentItem);
                    currentItem.classList.add('expanded');
                    expandedCount++;

                    // Move to parent LI (skip UL)
                    const parentUL = currentItem.parentElement;
                    if (parentUL && parentUL.tagName === 'UL') {
                        currentItem = parentUL.parentElement;
                    } else {
                        break;
                    }
                }
                console.log('Expanded', expandedCount, 'items in hierarchy');

                // Highlight the current link
                tocLink.classList.add('toc-active');
                console.log('Added toc-active class to link');

                // Scroll TOC to show the active item
                setTimeout(() => {
                    tocLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    console.log('Scrolled to TOC item');
                }, 200);

            } catch (e) {
                console.log('Could not expand TOC:', e);
            }
        }

        window.openResult = function(sourcePath, headingId, displayHeading, occurrenceIndex, resultIndex) {
            searchResults.classList.add('hidden');
            contentFrame.classList.remove('hidden');

            // Keep navigation buttons visible if we have results
            if (allSearchResults.length > 0) {
                nextResultBtn.classList.remove('hidden');
                prevResultBtn.classList.remove('hidden');
            }

            // Store these globally so they're accessible in async callbacks
            currentHeadingId = headingId;
            currentOccurrenceIndex = occurrenceIndex;

            // Track current result index if provided
            if (resultIndex !== undefined) {
                currentResultIndex = resultIndex;
            }

            const highlightAndScroll = () => {
                try {
                    const iframeDoc = contentFrame.contentWindow.document;

                    console.log('highlightAndScroll called with:', {
                        currentSearchQuery,
                        currentOccurrenceIndex,
                        currentHeadingId
                    });

                    // First, find the Nth occurrence BEFORE removing highlights
                    // This ensures we're counting on the original unmodified DOM
                    let targetElement = null;
                    let foundOccurrence = 0;

                    if (currentSearchQuery && currentOccurrenceIndex) {
                        const escapedQuery = currentSearchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const wholeWord = document.getElementById('whole-word-search').checked;
                        const caseSensitive = document.getElementById('case-sensitive-search').checked;
                        const regexFlags = caseSensitive ? '' : 'i';
                        const regex = wholeWord
                            ? new RegExp(`\\b${escapedQuery}\\b`, regexFlags)
                            : new RegExp(escapedQuery, regexFlags);

                        // Count by paragraphs and headings (same as during search)
                        const content = iframeDoc.getElementById('content');
                        if (content) {
                            // Get fresh elements each time (not affected by previous highlights)
                            const elements = content.querySelectorAll('p, h1, h2, h3, h4, h5, h6');

                            for (let el of elements) {
                                // Get the raw text content (strips any highlight markup)
                                const textContent = el.textContent;

                                // Check if this element's text contains our search term
                                if (regex.test(textContent)) {
                                    foundOccurrence++;

                                    // Is this the occurrence we're looking for?
                                    if (foundOccurrence === currentOccurrenceIndex) {
                                        targetElement = el;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // Fallback: Scroll to the heading using ID
                    if (!targetElement && currentHeadingId) {
                        targetElement = iframeDoc.getElementById(currentHeadingId);
                    }

                    // NOW remove any existing highlights (after we found the target)
                    const existingHighlights = iframeDoc.querySelectorAll('.search-term-highlight');
                    existingHighlights.forEach(el => {
                        const parent = el.parentNode;
                        parent.replaceChild(iframeDoc.createTextNode(el.textContent), el);
                        parent.normalize();
                    });

                    // Add highlights first, then scroll to the first highlighted term
                    setTimeout(() => {
                        if (currentSearchQuery) {
                            const escapedQuery = currentSearchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            const wholeWord = document.getElementById('whole-word-search').checked;
                            const caseSensitive = document.getElementById('case-sensitive-search').checked;
                            const regexFlags = caseSensitive ? 'g' : 'gi';
                            const regex = wholeWord
                                ? new RegExp(`\\b(${escapedQuery})\\b`, regexFlags)
                                : new RegExp(`(${escapedQuery})`, regexFlags);

                            const content = iframeDoc.getElementById('content');
                            if (content) {
                                // Find the target section first (after the heading)
                                let searchStart = content;
                                if (targetElement) {
                                    // Find the next content after the heading
                                    searchStart = targetElement.parentElement || content;
                                }

                                const walker = iframeDoc.createTreeWalker(
                                    searchStart,
                                    NodeFilter.SHOW_TEXT,
                                    null,
                                    false
                                );

                                const nodesToReplace = [];
                                let node;
                                let firstMatchNode = null;

                                while (node = walker.nextNode()) {
                                    if (node.textContent.match(regex)) {
                                        nodesToReplace.push(node);
                                        if (!firstMatchNode) {
                                            firstMatchNode = node;
                                        }
                                    }
                                }

                                nodesToReplace.forEach(textNode => {
                                    const span = iframeDoc.createElement('span');
                                    span.innerHTML = textNode.textContent.replace(regex, '<mark class="search-term-highlight" style="background: #fef08a; padding: 2px 4px; border-radius: 2px; font-weight: 600;">$1</mark>');
                                    textNode.parentNode.replaceChild(span, textNode);
                                });

                                // Scroll directly to the target element (the Nth occurrence paragraph)
                                setTimeout(() => {
                                    if (targetElement) {
                                        // Scroll to the specific target element we found
                                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                                        // Expand TOC to show current location
                                        expandTOCToElement(iframeDoc, currentHeadingId);
                                    } else {
                                        // Fallback: scroll to first highlight if no target found
                                        const firstHighlight = iframeDoc.querySelector('.search-term-highlight');
                                        if (firstHighlight) {
                                            firstHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });

                                            // Try to expand TOC based on nearby heading
                                            const nearbyHeading = findNearestHeading(iframeDoc, firstHighlight);
                                            if (nearbyHeading) {
                                                expandTOCToElement(iframeDoc, nearbyHeading.id);
                                            }
                                        }
                                    }
                                }, 100);
                            }
                        } else if (targetElement) {
                            // No search query, just scroll to heading
                            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 300);
                } catch (e) {
                    console.log('Could not highlight or scroll:', e);
                }
            };

            // Switch to the correct book if needed
            if (sourcePath !== currentSrc) {
                console.log(`Switching from ${currentSrc} to ${sourcePath}`);

                // Find the button for the target book
                let buttonFound = false;
                buttons.forEach(btn => {
                    if (btn.getAttribute('data-src') === sourcePath) {
                        buttonFound = true;

                        // Remove active class from all buttons
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        // Show loading
                        loading.classList.remove('hidden');
                        contentFrame.classList.add('hidden');
                        isLoading = true;

                        // Set up ONE onload handler that waits for the book to fully load
                        contentFrame.onload = function() {
                            console.log('Book loaded, waiting for DOM to stabilize...');

                            // Wait for DOM to be ready
                            const waitForStableDOM = () => {
                                try {
                                    const iframeDoc = contentFrame.contentWindow.document;
                                    const content = iframeDoc.getElementById('content');
                                    const collapseStyle = iframeDoc.getElementById('toc-collapse-style');

                                    if (!content || !collapseStyle) {
                                        setTimeout(waitForStableDOM, 200);
                                        return;
                                    }

                                    const elementCount = content.querySelectorAll('p, h1, h2, h3, h4, h5, h6').length;

                                    if (elementCount === 0) {
                                        setTimeout(waitForStableDOM, 200);
                                        return;
                                    }

                                    console.log(`DOM ready with ${elementCount} elements. Waiting 2s for complete stability...`);

                                    // Wait for everything to fully render
                                    setTimeout(() => {
                                        console.log('Book fully loaded. Showing iframe...');

                                        // Show the iframe first
                                        loading.classList.add('hidden');
                                        contentFrame.classList.remove('hidden');
                                        isLoading = false;
                                        currentSrc = sourcePath;
                                        loadedPages.add(sourcePath);

                                        // NOW perform the search on the fully loaded and visible book
                                        setTimeout(() => {
                                            console.log('Now applying search...');
                                            console.log('Search query:', currentSearchQuery);
                                            console.log('Occurrence index:', currentOccurrenceIndex);
                                            console.log('Heading ID:', currentHeadingId);

                                            try {
                                                highlightAndScroll();
                                            } catch (err) {
                                                console.error('Highlight error:', err);
                                            }
                                        }, 1000);
                                    }, 2000);
                                } catch (e) {
                                    console.error('DOM check error:', e);
                                    setTimeout(waitForStableDOM, 200);
                                }
                            };

                            // Start checking after initial delay
                            setTimeout(waitForStableDOM, 300);
                        };

                        // Now trigger the book load
                        console.log('Loading book:', sourcePath);
                        contentFrame.src = sourcePath;
                    }
                });

                if (!buttonFound) {
                    console.log('Button not found for:', sourcePath);
                }
            } else {
                // Same book, just apply search
                console.log('Same book, applying search directly');
                highlightAndScroll();
            }
        };

        searchBtn.addEventListener('click', () => performSearch(searchInput.value, false));
        searchAllBtn.addEventListener('click', () => performSearch(searchInput.value, true));
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch(searchInput.value, false);
            }
        });

        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + F - Focus search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                searchInput.focus();
                searchInput.select();
            }

            // Ctrl/Cmd + N - Next result
            if ((e.ctrlKey || e.metaKey) && e.key === 'n' && allSearchResults.length > 0) {
                e.preventDefault();
                nextResultBtn.click();
            }

            // Ctrl/Cmd + P - Previous result
            if ((e.ctrlKey || e.metaKey) && e.key === 'p' && allSearchResults.length > 0) {
                e.preventDefault();
                prevResultBtn.click();
            }

            // Escape - Close search results
            if (e.key === 'Escape') {
                if (!searchResults.classList.contains('hidden')) {
                    window.closeSearch();
                }
            }

            // Arrow Right - Next result
            if (e.key === 'ArrowRight' && allSearchResults.length > 0 && !searchResults.classList.contains('hidden')) {
                nextResultBtn.click();
            }

            // Arrow Left - Previous result
            if (e.key === 'ArrowLeft' && allSearchResults.length > 0 && !searchResults.classList.contains('hidden')) {
                prevResultBtn.click();
            }
        });

        // Previous result button handler
        prevResultBtn.addEventListener('click', () => {
            if (allSearchResults.length === 0) return;

            // Move to previous result (circular)
            currentResultIndex = (currentResultIndex - 1 + allSearchResults.length) % allSearchResults.length;
            const prevResult = allSearchResults[currentResultIndex];

            console.log(`Moving to result ${currentResultIndex + 1} of ${allSearchResults.length}`);
            updateResultCounter();

            // Open the previous result
            window.openResult(
                prevResult.sourcePath,
                prevResult.headingId,
                prevResult.heading,
                prevResult.occurrenceIndex,
                currentResultIndex
            );
        });

        // Next result button handler
        nextResultBtn.addEventListener('click', () => {
            if (allSearchResults.length === 0) return;

            // Move to next result (circular)
            currentResultIndex = (currentResultIndex + 1) % allSearchResults.length;
            const nextResult = allSearchResults[currentResultIndex];

            console.log(`Moving to result ${currentResultIndex + 1} of ${allSearchResults.length}`);
            updateResultCounter();

            // Open the next result
            window.openResult(
                nextResult.sourcePath,
                nextResult.headingId,
                nextResult.heading,
                nextResult.occurrenceIndex,
                currentResultIndex
            );
        });

        // Delegated event handler for search result clicks
        searchResults.addEventListener('click', (e) => {
            // Find the closest .search-result-item parent
            const resultItem = e.target.closest('.search-result-item');
            if (!resultItem) return;

            // Get data attributes
            const sourcePath = resultItem.dataset.sourcePath;
            const headingId = resultItem.dataset.headingId;
            const occurrence = parseInt(resultItem.dataset.occurrence);
            const resultIndex = parseInt(resultItem.dataset.resultIndex);

            // Get the actual result object for the heading text
            const result = allSearchResults[resultIndex];
            if (!result) return;

            // Update counter
            updateResultCounter();

            // Call openResult with the data
            window.openResult(
                sourcePath,
                headingId,
                result.heading,
                occurrence,
                resultIndex
            );
        });
    </script>
</body>
</html>
